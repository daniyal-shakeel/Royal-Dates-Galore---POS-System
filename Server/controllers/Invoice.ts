import { Request, Response } from 'express';
import { Invoice } from '../models/Invoice';
import { Customer } from '../models/Customer';
import { Product } from '../models/Product';
import { validateData, ValidationError, invoiceStatusSchema, invoiceSchema, validateMongoId } from '../utils/validation';
import mongoose from 'mongoose';

/**
 * Helper function to calculate due date from payment terms
 * Supports formats like "Net 15", "Net 30", "Due on Receipt", etc.
 */
const calculateDueDate = (paymentTerms: string, invoiceDate: Date = new Date()): Date => {
    const dueDate = new Date(invoiceDate);
    
    // Handle "Due on Receipt" or "Immediate"
    if (paymentTerms.toLowerCase().includes('receipt') || paymentTerms.toLowerCase().includes('immediate')) {
        return dueDate;
    }
    
    // Extract number from payment terms (e.g., "Net 15" -> 15)
    const match = paymentTerms.match(/\d+/);
    if (match) {
        const days = parseInt(match[0], 10);
        dueDate.setDate(dueDate.getDate() + days);
        return dueDate;
    }
    
    // Default to 30 days if no number found
    dueDate.setDate(dueDate.getDate() + 30);
    return dueDate;
    
};

export const createInvoice = async (req: Request, res: Response) => {
    try {
        // Validate and sanitize input data
        const validatedData = validateData(invoiceSchema, req.body);
        console.log(validatedData);
        
        // Validate MongoDB ObjectIds
        try {
            validateMongoId(validatedData.customer_id);
            validateMongoId(validatedData.sales_rep_id);
            validatedData.items.forEach(item => {
                validateMongoId(item.product_id);
            });
            if (validatedData.estimate_id) {
                validateMongoId(validatedData.estimate_id);
            }
        } catch (error) {
            if (error instanceof ValidationError) {
                return res.status(400).json({
                    message: 'Validation failed',
                    errors: error.errors
                });
            }
            throw error;
        }

        // Verify customer exists
        const customer = await Customer.findById(validatedData.customer_id);
        if (!customer) {
            return res.status(404).json({ 
                message: 'Customer not found',
                errors: [{ field: 'customer_id', message: 'Customer with this ID does not exist' }]
            });
        }

        // Verify all products exist
        const productIds = validatedData.items.map(item => new mongoose.Types.ObjectId(item.product_id));
        const products = await Product.find({ _id: { $in: productIds } });
        
        if (products.length !== validatedData.items.length) {
            const foundIds = products.map(p => p._id.toString());
            const missingIds = validatedData.items
                .filter(item => !foundIds.includes(item.product_id))
                .map(item => item.product_id);
            
            return res.status(404).json({
                message: 'One or more products not found',
                errors: [{ 
                    field: 'items', 
                    message: `Products with IDs ${missingIds.join(', ')} do not exist` 
                }]
            });
        }

        // Calculate due date from payment terms
        const invoiceDate = new Date();
        const dueDate = calculateDueDate(validatedData.paymentTerms, invoiceDate);

        // Prepare invoice data
        const invoiceData: any = {
            customer_id: new mongoose.Types.ObjectId(validatedData.customer_id),
            items: validatedData.items.map(item => ({
                product_id: new mongoose.Types.ObjectId(item.product_id),
                quantity: item.quantity,
                unit_price: item.unit_price
            })),
            tax_type: validatedData.tax_type,
            tax_value: validatedData.tax_value,
            discount_type: validatedData.discount_type,
            discount_value: validatedData.discount_value,
            paymentTerms: validatedData.paymentTerms,
            due_date: dueDate,
            deposit_received: validatedData.deposit_received || 0,
            notes: validatedData.notes || '',
            signature: validatedData.signature,
            sales_rep_id: new mongoose.Types.ObjectId(validatedData.sales_rep_id),
            status: 'Pending' as const
        };

        // Add estimate_id if provided
        if (validatedData.estimate_id) {
            invoiceData.estimate_id = new mongoose.Types.ObjectId(validatedData.estimate_id);
        }

        // Create new invoice (reference number and totals will be auto-generated by pre-save hook)
        const newInvoice = new Invoice(invoiceData);
        await newInvoice.save();

        // Populate references for response
        await newInvoice.populate('customer_id', 'customerName customerEmail customerPhone customerBillingAddress');
        await newInvoice.populate('items.product_id', 'product_name product_code description pricing_inventory');

        return res.status(201).json({
            message: 'Invoice created successfully',
            invoice: {
                id: newInvoice._id,
                invoiceReference: newInvoice.invoiceReference,
                customer_id: newInvoice.customer_id,
                items: newInvoice.items,
                subtotal: newInvoice.subtotal,
                tax_type: newInvoice.tax_type,
                tax_value: newInvoice.tax_value,
                discount_type: newInvoice.discount_type,
                discount_value: newInvoice.discount_value,
                total: newInvoice.total,
                balance: newInvoice.balance,
                total_paid: newInvoice.total_paid,
                due_payment: newInvoice.due_payment,
                deposit_received: newInvoice.deposit_received,
                status: newInvoice.status,
                paymentTerms: newInvoice.paymentTerms,
                due_date: newInvoice.due_date,
                notes: newInvoice.notes,
                signature: newInvoice.signature,
                sales_rep_id: newInvoice.sales_rep_id,
                estimate_id: newInvoice.estimate_id,
                createdAt: newInvoice.createdAt,
                updatedAt: newInvoice.updatedAt
            }
        });
    } catch (error) {
        if (error instanceof ValidationError) {
            return res.status(400).json({
                message: 'Validation failed',
                errors: error.errors
            });
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        return res.status(500).json({ 
            message: 'Error creating invoice', 
            error: errorMessage
        });
    }
}

export const deleteInvoice = async (_req:Request, res:Response) => {
    return res.status(200).json({ message: 'Invoice deleted successfully' });
}

export const updateInvoice = async (_req:Request, res:Response) => {
    return res.status(200).json({ message: 'Invoice updated successfully' });
}

export const getInvoices = async (_req: Request, res: Response) => {
    try {
        const invoices = await Invoice.find()
            .populate('customer_id', 'customerName customerEmail customerPhone customerBillingAddress')
            .populate('items.product_id', 'product_name product_code description pricing_inventory')
            .populate('sales_rep_id', 'name email')
            .sort({ createdAt: -1 }); // Sort by newest first
        
        return res.status(200).json({ 
            message: 'Invoices fetched successfully', 
            invoices,
            length: invoices.length 
        });
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        return res.status(500).json({ 
            message: 'Error fetching invoices', 
            error: errorMessage 
        });
    }
}

export const getInvoiceById = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        
        // Validate MongoDB ObjectId format
        try {
            validateMongoId(id);
        } catch (error) {
            if (error instanceof ValidationError) {
                return res.status(400).json({ 
                    message: 'Invalid invoice ID',
                    errors: [{ field: 'id', message: error.errors[0].message }]
                });
            }
            throw error;
        }
        
        // Find invoice and populate related data
        const invoice = await Invoice.findById(id)
            .populate('customer_id', 'customerName customerEmail customerPhone customerBillingAddress')
            .populate('items.product_id', 'product_name product_code description pricing_inventory')
            .populate('sales_rep_id', 'name email')
            .populate('estimate_id', 'estimateReference status');
        
        if (!invoice) {
            return res.status(404).json({ 
                message: 'Invoice not found',
                errors: [{ field: 'id', message: 'Invoice with this ID does not exist' }]
            });
        }
        
        return res.status(200).json({ 
            message: 'Invoice fetched successfully', 
            invoice 
        });
    } catch (error) {
        if (error instanceof ValidationError) {
            return res.status(400).json({
                message: 'Validation failed',
                errors: error.errors
            });
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        return res.status(500).json({ 
            message: 'Error fetching invoice', 
            error: errorMessage 
        });
    }
}

/**
 * Valid status transitions map
 * Key: current status, Value: array of allowed next statuses
 */
const validInvoiceStatusTransitions: Record<string, string[]> = {
    'Pending': ['Paid', 'Partially Paid', 'Overdue', 'Cancelled'],
    'Partially Paid': ['Paid', 'Partially Paid', 'Overdue', 'Cancelled'],
    'Overdue': ['Paid', 'Partially Paid', 'Cancelled'],
    'Paid': [], // Final status - no transitions allowed
    'Cancelled': [] // Final status - no transitions allowed
};

/**
 * Check if status transition is valid
 */
const isValidInvoiceStatusTransition = (currentStatus: string, newStatus: string): boolean => {
    // Same status is always valid (idempotent)
    if (currentStatus === newStatus) {
        return true;
    }
    
    // Check if transition is allowed
    const allowedTransitions = validInvoiceStatusTransitions[currentStatus] || [];
    return allowedTransitions.includes(newStatus);
};

export const updateInvoiceStatus = async (req: Request, res: Response) => {
    try {
        const {id} = req.params;
        
        // Validate MongoDB ObjectId format
        try {
            validateMongoId(id);
        } catch (error) {
            if (error instanceof ValidationError) {
                return res.status(400).json({ 
                    message: 'Invalid invoice ID',
                    errors: [{ field: 'id', message: error.errors[0].message }]
                });
            }
            throw error;
        }

        // Validate status update data
        let validatedData;
        try {
            validatedData = validateData(invoiceStatusSchema, req.body);
        } catch (error) {
            if (error instanceof ValidationError) {
                return res.status(400).json({
                    message: 'Validation failed',
                    errors: error.errors
                });
            }
            throw error;
        }

        // Find invoice
        const invoice = await Invoice.findById(id);
        if (!invoice) {
            return res.status(404).json({ 
                message: 'Invoice not found',
                errors: [{ field: 'id', message: 'Invoice with this ID does not exist' }]
            });
        }

        const currentStatus = invoice.status;
        const newStatus = validatedData.status;

        console.log(currentStatus, newStatus);

        // Check if status is already the same (idempotent operation)
        if (currentStatus === newStatus && newStatus !== 'Partially Paid') {
            // Populate for response
            await invoice.populate('customer_id', 'customerName customerEmail customerPhone customerBillingAddress');
            await invoice.populate('items.product_id', 'product_name product_code description pricing_inventory');
            
            return res.status(200).json({
                message: 'Invoice status is already set to this value',
                invoice: {
                    id: invoice._id,
                    invoiceReference: invoice.invoiceReference,
                    status: invoice.status,
                    previousStatus: currentStatus,
                    statusChanged: false,
                    total: invoice.total,
                    total_paid: invoice.total_paid,
                    due_payment: invoice.due_payment
                }
            });
        }

        // Check if current status is a final status (Paid, Cancelled)
        if (['Paid', 'Cancelled'].includes(currentStatus)) {
            return res.status(400).json({
                message: 'Cannot change status of finalized invoice',
                errors: [{
                    field: 'status',
                    message: `Invoice is already ${currentStatus}. Status cannot be changed from final states (Paid, Cancelled).`
                }],
                invoice: {
                    id: invoice._id,
                    invoiceReference: invoice.invoiceReference,
                    currentStatus: currentStatus
                }
            });
        }

        // Check if status transition is valid
        if (!isValidInvoiceStatusTransition(currentStatus, newStatus)) {
            return res.status(400).json({
                message: 'Invalid status transition',
                errors: [{
                    field: 'status',
                    message: `Cannot change status from '${currentStatus}' to '${newStatus}'. Allowed transitions from '${currentStatus}': ${validInvoiceStatusTransitions[currentStatus]?.join(', ') || 'none'}`
                }],
                invoice: {
                    id: invoice._id,
                    invoiceReference: invoice.invoiceReference,
                    currentStatus: currentStatus,
                    requestedStatus: newStatus
                }
            });
        }

        // Handle Partially Paid status
        if (newStatus === 'Partially Paid') {
            const paymentAmount = validatedData.payment_amount;
            
            if (!paymentAmount || paymentAmount <= 0) {
                return res.status(400).json({
                    message: 'Payment amount is required for Partially Paid status',
                    errors: [{
                        field: 'payment_amount',
                        message: 'Payment amount must be greater than 0'
                    }]
                });
            }

            // Check if payment amount exceeds remaining balance
            const currentBalance = invoice.balance || invoice.total - (invoice.total_paid || 0);
            if (paymentAmount > currentBalance) {
                return res.status(400).json({
                    message: 'Payment amount exceeds remaining balance',
                    errors: [{
                        field: 'payment_amount',
                        message: `Payment amount (${paymentAmount}) cannot exceed remaining balance (${currentBalance})`
                    }],
                    invoice: {
                        id: invoice._id,
                        invoiceReference: invoice.invoiceReference,
                        total: invoice.total,
                        total_paid: invoice.total_paid || 0,
                        balance: currentBalance
                    }
                });
            }

            // Add payment to payments array
            const newPayment = {
                amount: paymentAmount,
                payment_date: new Date(),
                payment_method: validatedData.payment_method || '',
                notes: validatedData.payment_notes || ''
            };

            // Initialize payments array if it doesn't exist
            if (!invoice.payments) {
                invoice.payments = [];
            }
            invoice.payments.push(newPayment);

            // Calculate new totals
            invoice.total_paid = invoice.payments.reduce((sum, payment) => sum + payment.amount, 0);
            invoice.due_payment = Math.max(0, invoice.total - invoice.total_paid);
            invoice.balance = invoice.due_payment;

            // If fully paid, set status to Paid
            if (invoice.due_payment === 0) {
                invoice.status = 'Paid';
            } else {
                invoice.status = 'Partially Paid';
            }
        } else if (newStatus === 'Paid') {
            // If setting to Paid, ensure full payment
            const currentBalance = invoice.balance || invoice.total - (invoice.total_paid || 0);
            
            if (currentBalance > 0) {
                // If there's remaining balance, add it as a payment
                if (!invoice.payments) {
                    invoice.payments = [];
                }
                
                const finalPayment = {
                    amount: currentBalance,
                    payment_date: new Date(),
                    payment_method: validatedData.payment_method || '',
                    notes: validatedData.payment_notes || 'Final payment'
                };
                
                invoice.payments.push(finalPayment);
                invoice.total_paid = invoice.total;
                invoice.due_payment = 0;
                invoice.balance = 0;
            }
            
            invoice.status = 'Paid';
        } else {
            // For other statuses (Overdue, Cancelled), just update status
            invoice.status = newStatus;
        }

        // Save invoice
        await invoice.save();

        // Populate references for response
        await invoice.populate('customer_id', 'customerName customerEmail customerPhone customerBillingAddress');
        await invoice.populate('items.product_id', 'product_name product_code description pricing_inventory');

        const response: any = {
            message: 'Invoice status updated successfully',
            invoice: {
                id: invoice._id,
                invoiceReference: invoice.invoiceReference,
                status: invoice.status,
                previousStatus: currentStatus,
                statusChanged: true,
                total: invoice.total,
                total_paid: invoice.total_paid,
                due_payment: invoice.due_payment,
                balance: invoice.balance,
                payments: invoice.payments
            }
        };

        // Add specific message for Partially Paid
        if (newStatus === 'Partially Paid') {
            response.message = 'Invoice status updated to Partially Paid. Payment recorded successfully.';
            response.payment_details = {
                payment_amount: validatedData.payment_amount,
                payment_date: invoice.payments[invoice.payments.length - 1].payment_date,
                remaining_balance: invoice.due_payment
            };
        }

        return res.status(200).json(response);
    } catch (error) {
        if (error instanceof ValidationError) {
            return res.status(400).json({
                message: 'Validation failed',
                errors: error.errors
            });
        }
        
        const errorMessage = error instanceof Error ? error.message : String(error);
        return res.status(500).json({ 
            message: 'Error updating invoice status', 
            error: errorMessage
        });
    }
}

